Cookbook
========

### Inner Classes and Path-Dependent Types

To instantiate path-dependent types via constructor, their prefix type must be present in the object graph:

```scala mdoc:reset
import distage._

trait Path {
  class A
  class B
}

val path = new Path {}

val module = new ModuleDef {
  make[path.A]
  make[path.type].from[path.type](path: path.type)
}
```

The same applies to type projections:

```scala mdoc
val module1 = new ModuleDef {
  make[Path#B]
  make[Path].from(new Path {})
}
```

Function and instance bindings and constructors generated by implicit @scaladoc[AnyConstructor](izumi.distage.constructors.AnyConstructor) do not require the type prefix:

```scala mdoc
val module2 = new ModuleDef {
  make[Path#B].fromValue {
    val path = new Path {}
    new path.B
  }
}
```

### Depending on Locator

Classes can depend on the Locator (container of the final object graph):

```scala
import distage._

class A(all: LocatorRef) {
  def c = all.get.get[C]
}
class B
class C

val module = new ModuleDef {
  make[A]
  make[B]
  make[C]
}

val locator = Injector().produce(module)

assert(locator.get[A].c eq locator.get[C]) 
```

Locator contains metadata about the plan and the bindings from which it was ultimately created:

```scala
// Plan that created this locator
val plan: OrderedPlan = locator.plan

// Bindings from which the Plan was built
val moduleDef: ModuleBase = plan.definition
```
