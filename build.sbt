// DO NOT EDIT THIS FILE
// IT IS AUTOGENERATED BY `sbtgen.sc` SCRIPT
// ALL CHANGES WILL BE LOST


import sbtcrossproject.CrossPlugin.autoImport.{crossProject, CrossType}

import com.github.sbt.git.SbtGit.GitKeys._

enablePlugins(SbtgenVerificationPlugin)

disablePlugins(AssemblyPlugin)

lazy val `fundamentals-basics` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-basics"))
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-basicsJVM` = `fundamentals-basics`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-basicsJS` = `fundamentals-basics`.js
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-functional` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-functional"))
  .dependsOn(
    `fundamentals-basics` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-functionalJVM` = `fundamentals-functional`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-functionalJS` = `fundamentals-functional`.js
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-collections` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-collections"))
  .dependsOn(
    `fundamentals-basics` % "test->compile;compile->compile",
    `fundamentals-functional` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-collectionsJVM` = `fundamentals-collections`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-collectionsJS` = `fundamentals-collections`.js
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-literals` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-literals"))
  .dependsOn(
    `fundamentals-basics` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-literalsJVM` = `fundamentals-literals`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-literalsJS` = `fundamentals-literals`.js
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-orphans` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-orphans"))
  .dependsOn(
    `fundamentals-basics` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "org.typelevel" %%% "cats-core" % V.cats % Optional,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Optional,
      "dev.zio" %%% "zio" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect % Optional,
      "dev.zio" %%% "zio-interop-cats" % V.zio_interop_cats % Optional excludeAll("dev.zio" %% "izumi-reflect")
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    Compile / doc / sources := { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq.empty
      case (_, _) => (Compile / doc / sources).value
    } }
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-orphansJVM` = `fundamentals-orphans`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-orphansJS` = `fundamentals-orphans`.js
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-language` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-language"))
  .dependsOn(
    `fundamentals-literals` % "test->compile;compile->compile",
    `fundamentals-basics` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty },
    libraryDependencies ++= {
      val version = scalaVersion.value
      if (version.startsWith("0.") || version.startsWith("3.")) {
        Seq(
          "org.scala-lang" %% "scala3-compiler" % scalaVersion.value % Provided
        )
      } else Seq.empty
    }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-languageJVM` = `fundamentals-language`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-languageJS` = `fundamentals-language`.js
  .enablePlugins(ScalaJSBundlerPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-platform` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-platform"))
  .dependsOn(
    `fundamentals-functional` % "test->compile;compile->compile",
    `fundamentals-basics` % "test->compile;compile->compile",
    `fundamentals-language` % "test->compile;compile->compile",
    `fundamentals-collections` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) },
    Test / npmDependencies ++= Seq(
      (  "hash.js",  "1.1.7")
    )
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-platformJVM` = `fundamentals-platform`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-platformJS` = `fundamentals-platform`.js
  .enablePlugins(ScalaJSBundlerPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-functoid` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-functoid"))
  .dependsOn(
    `fundamentals-platform` % "test->compile;compile->compile",
    `fundamentals-language` % "test->compile;compile->compile",
    `fundamentals-collections` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-functoidJVM` = `fundamentals-functoid`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-functoidJS` = `fundamentals-functoid`.js
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-json-circe` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-json-circe"))
  .dependsOn(
    `fundamentals-platform` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "io.circe" %%% "circe-core" % V.circe,
      "org.typelevel" %% "jawn-parser" % V.jawn % Test,
      "io.circe" %%% "circe-literal" % V.circe % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided,
      "io.circe" %%% "circe-derivation" % V.circe_derivation % Test,
      "io.circe" %%% "circe-generic" % V.circe % Test
    ) else Seq.empty },
    libraryDependencies ++= {
      val version = scalaVersion.value
      if (version.startsWith("0.") || version.startsWith("3.")) {
        Seq(
          "io.circe" %%% "circe-generic" % V.circe
        )
      } else Seq.empty
    }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    Compile / libraryDependencySchemes += "io.circe" %% "circe-core" % VersionScheme.Always,
    Compile / libraryDependencySchemes += "io.circe" %% "circe-core_sjs1" % VersionScheme.Always
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-json-circeJVM` = `fundamentals-json-circe`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-json-circeJS` = `fundamentals-json-circe`.js
  .disablePlugins(AssemblyPlugin)

lazy val `fundamentals-bio` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("fundamentals/fundamentals-bio"))
  .dependsOn(
    `fundamentals-language` % "test->compile;compile->compile",
    `fundamentals-orphans` % "test->compile;compile->compile",
    `fundamentals-collections` % "test->compile;compile->compile",
    `fundamentals-basics` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "org.typelevel" %%% "cats-core" % V.cats % Optional,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Optional,
      "dev.zio" %%% "zio" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect % Optional,
      "dev.zio" %%% "zio-managed" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "zio-interop-tracer" % V.zio_interop_cats,
      "org.typelevel" %%% "cats-effect-laws" % V.cats_effect % Test,
      "org.typelevel" %%% "cats-effect-testkit" % V.cats_effect % Test,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "org.typelevel" %%% "discipline-core" % V.discipline % Test,
      "org.typelevel" %%% "discipline-scalatest" % V.discipline_scalatest % Test,
      "dev.zio" %%% "zio-interop-cats" % V.zio_interop_cats % Test excludeAll("dev.zio" %% "izumi-reflect")
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    Compile / doc / sources := { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq.empty
      case (_, _) => (Compile / doc / sources).value
    } }
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `fundamentals-bioJVM` = `fundamentals-bio`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `fundamentals-bioJS` = `fundamentals-bio`.js
  .settings(
    libraryDependencies ++= Seq(
      "io.github.cquiroz" %%% "scala-java-time" % V.scala_java_time % Test
    )
  )
  .disablePlugins(AssemblyPlugin)

lazy val `distage-core-api` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("distage/distage-core-api"))
  .dependsOn(
    `fundamentals-platform` % "test->compile;compile->compile",
    `fundamentals-functoid` % "test->compile;compile->compile",
    `fundamentals-bio` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "org.typelevel" %%% "cats-core" % V.cats % Optional,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Optional,
      "dev.zio" %%% "zio" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect % Optional,
      "org.typelevel" %%% "cats-core" % V.cats % Test,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Test,
      "dev.zio" %%% "zio" % V.zio % Test excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect % Test,
      "dev.zio" %%% "zio-managed" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect")
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `distage-core-apiJVM` = `distage-core-api`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `distage-core-apiJS` = `distage-core-api`.js
  .disablePlugins(AssemblyPlugin)

lazy val `distage-core-proxy-bytebuddy` = project.in(file("distage/distage-core-proxy-bytebuddy"))
  .dependsOn(
    `distage-core-apiJVM` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test,
      "net.bytebuddy" % "byte-buddy" % V.bytebuddy
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `distage-framework-api` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("distage/distage-framework-api"))
  .dependsOn(
    `distage-core-api` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `distage-framework-apiJVM` = `distage-framework-api`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `distage-framework-apiJS` = `distage-framework-api`.js
  .disablePlugins(AssemblyPlugin)

lazy val `distage-core` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("distage/distage-core"))
  .dependsOn(
    `distage-core-api` % "test->compile;compile->compile",
    `fundamentals-platform` % "test->test;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "org.typelevel" %%% "cats-core" % V.cats % Optional,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Optional,
      "dev.zio" %%% "zio" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect % Optional,
      "dev.zio" %%% "zio-interop-cats" % V.zio_interop_cats % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "javax.inject" % "javax.inject" % "1" % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) },
    Test / npmDependencies ++= Seq(
      (  "hash.js",  "1.1.7")
    )
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `distage-coreJVM` = `distage-core`.jvm
  .dependsOn(
    `distage-core-proxy-bytebuddy` % "test->compile;compile->compile"
  )
  .disablePlugins(AssemblyPlugin)
lazy val `distage-coreJS` = `distage-core`.js
  .settings(
    libraryDependencies ++= Seq(
      "io.github.cquiroz" %%% "scala-java-time" % V.scala_java_time % Test
    )
  )
  .enablePlugins(ScalaJSBundlerPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `distage-extension-config` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("distage/distage-extension-config"))
  .dependsOn(
    `distage-core-api` % "test->compile;compile->compile",
    `distage-core` % "test->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "com.softwaremill.magnolia1_2" %%% "magnolia" % V.magnolia,
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `distage-extension-configJVM` = `distage-extension-config`.jvm
  .settings(
    libraryDependencies ++= Seq(
      "com.github.pureconfig" %% "pureconfig-core" % V.pureconfig
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      "com.github.pureconfig" %% "pureconfig-magnolia" % V.pureconfig
    ) else Seq.empty }
  )
  .disablePlugins(AssemblyPlugin)
lazy val `distage-extension-configJS` = `distage-extension-config`.js
  .disablePlugins(AssemblyPlugin)

lazy val `distage-extension-logstage` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("distage/distage-extension-logstage"))
  .dependsOn(
    `distage-extension-config` % "test->compile;compile->compile",
    `distage-core-api` % "test->compile;compile->compile",
    `distage-core` % "test->compile",
    `logstage-core` % "test->test;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "dev.zio" %%% "zio" % V.zio % Test excludeAll("dev.zio" %% "izumi-reflect")
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `distage-extension-logstageJVM` = `distage-extension-logstage`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `distage-extension-logstageJS` = `distage-extension-logstage`.js
  .disablePlugins(AssemblyPlugin)

lazy val `distage-extension-plugins` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("distage/distage-extension-plugins"))
  .dependsOn(
    `distage-core-api` % "test->compile;compile->compile",
    `distage-core` % "test->compile",
    `distage-extension-config` % "test->compile",
    `logstage-core` % "test->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `distage-extension-pluginsJVM` = `distage-extension-plugins`.jvm
  .dependsOn(
    `fundamentals-platformJVM` % "test->compile,test"
  )
  .settings(
    libraryDependencies ++= Seq(
      "io.github.classgraph" % "classgraph" % V.classgraph,
      "dev.zio" %% "zio-managed" % V.zio % Test excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %% "zio-interop-cats" % V.zio_interop_cats % Test excludeAll("dev.zio" %% "izumi-reflect"),
      "org.typelevel" %% "cats-effect" % V.cats_effect % Test
    )
  )
  .disablePlugins(AssemblyPlugin)
lazy val `distage-extension-pluginsJS` = `distage-extension-plugins`.js
  .disablePlugins(AssemblyPlugin)

lazy val `distage-framework` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("distage/distage-framework"))
  .dependsOn(
    `distage-extension-logstage` % "test->compile;compile->compile",
    `logstage-rendering-circe` % "test->compile;compile->compile",
    `distage-core` % "test->compile;compile->compile",
    `distage-framework-api` % "test->compile;compile->compile",
    `distage-extension-plugins` % "test->compile;compile->compile",
    `distage-extension-config` % "test->compile;compile->compile",
    `distage-extension-plugins` % "test->test;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "org.typelevel" %%% "cats-core" % V.cats % Optional,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Optional,
      "org.typelevel" %%% "cats-core" % V.cats % Test,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Test,
      "dev.zio" %%% "zio" % V.zio % Test excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect % Test,
      "io.circe" %%% "circe-parser" % V.circe % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty },
    libraryDependencies ++= {
      val version = scalaVersion.value
      if (version.startsWith("0.") || version.startsWith("3.")) {
        Seq(
          "org.scala-lang" %% "scala3-compiler" % scalaVersion.value % Provided
        )
      } else Seq.empty
    }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `distage-frameworkJVM` = `distage-framework`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `distage-frameworkJS` = `distage-framework`.js
  .disablePlugins(AssemblyPlugin)

lazy val `distage-framework-docker` = project.in(file("distage/distage-framework-docker"))
  .dependsOn(
    `distage-coreJVM` % "test->compile;compile->compile",
    `distage-extension-configJVM` % "test->compile;compile->compile",
    `distage-framework-apiJVM` % "test->compile;compile->compile",
    `distage-extension-logstageJVM` % "test->compile;compile->compile",
    `distage-testkit-scalatest` % "test->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test,
      "org.typelevel" %% "cats-core" % V.cats % Test,
      "org.typelevel" %% "cats-effect" % V.cats_effect % Test,
      "dev.zio" %% "zio" % V.zio % Test excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %% "izumi-reflect" % V.izumi_reflect % Test,
      "com.github.docker-java" % "docker-java-core" % V.docker_java,
      "com.github.docker-java" % "docker-java-transport-zerodep" % V.docker_java
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `distage-testkit-core` = project.in(file("distage/distage-testkit-core"))
  .dependsOn(
    `distage-frameworkJVM` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `distage-testkit-scalatest` = project.in(file("distage/distage-testkit-scalatest"))
  .dependsOn(
    `distage-testkit-core` % "test->compile;compile->compile",
    `distage-coreJVM` % "test->compile;compile->compile",
    `distage-extension-pluginsJVM` % "test->compile;compile->compile",
    `distage-frameworkJVM` % "test->test;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test,
      "org.typelevel" %% "cats-core" % V.cats % Optional,
      "org.typelevel" %% "cats-effect" % V.cats_effect % Optional,
      "dev.zio" %% "zio" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %% "izumi-reflect" % V.izumi_reflect % Optional,
      "org.scalatest" %% "scalatest" % V.scalatest
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scalamock" %% "scalamock" % V.scalamock % Test
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    libraryDependencySchemes += "org.scala-lang.modules" %% "scala-xml" % VersionScheme.Always
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `distage-testkit-scalatest-sbt-module-filtering-test` = project.in(file("distage/distage-testkit-scalatest-sbt-module-filtering-test"))
  .dependsOn(
    `distage-testkit-scalatest` % "test->compile,test"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    publish / skip := true
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `logstage-core` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("logstage/logstage-core"))
  .dependsOn(
    `fundamentals-bio` % "test->compile;compile->compile",
    `fundamentals-platform` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "org.typelevel" %%% "cats-core" % V.cats % Optional,
      "org.typelevel" %%% "cats-effect" % V.cats_effect % Optional,
      "dev.zio" %%% "zio" % V.zio % Optional excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %%% "izumi-reflect" % V.izumi_reflect % Optional
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full),
      "org.scala-lang" % "scala-reflect" % scalaVersion.value % Provided
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `logstage-coreJVM` = `logstage-core`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `logstage-coreJS` = `logstage-core`.js
  .settings(
    libraryDependencies ++= Seq(
      "io.github.cquiroz" %%% "scala-java-time" % V.scala_java_time
    )
  )
  .disablePlugins(AssemblyPlugin)

lazy val `logstage-rendering-circe` = crossProject(JVMPlatform, JSPlatform).crossType(CrossType.Pure).in(file("logstage/logstage-rendering-circe"))
  .dependsOn(
    `logstage-core` % "test->test;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %%% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %%% "scalatest" % V.scalatest % Test,
      "io.circe" %%% "circe-core" % V.circe,
      "org.typelevel" %% "jawn-parser" % V.jawn % Test,
      "io.circe" %%% "circe-parser" % V.circe % Test,
      "io.circe" %%% "circe-literal" % V.circe % Test,
      "io.circe" %%% "circe-generic" % V.circe % Test,
      "dev.zio" %%% "zio" % V.zio % Test excludeAll("dev.zio" %% "izumi-reflect")
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .jvmSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head
  )
  .jsSettings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    scalaJSLinkerConfig := { scalaJSLinkerConfig.value.withBatchMode(true).withModuleKind(ModuleKind.CommonJSModule) }
  )
  .enablePlugins(SitePreviewPlugin)
lazy val `logstage-rendering-circeJVM` = `logstage-rendering-circe`.jvm
  .disablePlugins(AssemblyPlugin)
lazy val `logstage-rendering-circeJS` = `logstage-rendering-circe`.js
  .disablePlugins(AssemblyPlugin)

lazy val `logstage-adapter-slf4j` = project.in(file("logstage/logstage-adapter-slf4j"))
  .dependsOn(
    `logstage-coreJVM` % "test->test;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test,
      "org.slf4j" % "slf4j-api" % V.slf4j
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    Compile / compileOrder := CompileOrder.Mixed,
    Test / compileOrder := CompileOrder.Mixed,
    Test / classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.Flat
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `logstage-sink-slf4j` = project.in(file("logstage/logstage-sink-slf4j"))
  .dependsOn(
    `logstage-coreJVM` % "test->test;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test,
      "org.slf4j" % "slf4j-api" % V.slf4j,
      "org.slf4j" % "slf4j-simple" % V.slf4j % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "3.3.4-RC2",
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)

lazy val `microsite` = project.in(file("doc/microsite"))
  .dependsOn(
    `fundamentals-basicsJVM` % "test->compile;compile->compile",
    `fundamentals-functionalJVM` % "test->compile;compile->compile",
    `fundamentals-collectionsJVM` % "test->compile;compile->compile",
    `fundamentals-literalsJVM` % "test->compile;compile->compile",
    `fundamentals-orphansJVM` % "test->compile;compile->compile",
    `fundamentals-languageJVM` % "test->compile;compile->compile",
    `fundamentals-platformJVM` % "test->compile;compile->compile",
    `fundamentals-functoidJVM` % "test->compile;compile->compile",
    `fundamentals-json-circeJVM` % "test->compile;compile->compile",
    `fundamentals-bioJVM` % "test->compile;compile->compile",
    `distage-core-apiJVM` % "test->compile;compile->compile",
    `distage-core-proxy-bytebuddy` % "test->compile;compile->compile",
    `distage-framework-apiJVM` % "test->compile;compile->compile",
    `distage-coreJVM` % "test->compile;compile->compile",
    `distage-extension-configJVM` % "test->compile;compile->compile",
    `distage-extension-logstageJVM` % "test->compile;compile->compile",
    `distage-extension-pluginsJVM` % "test->compile;compile->compile",
    `distage-frameworkJVM` % "test->compile;compile->compile",
    `distage-framework-docker` % "test->compile;compile->compile",
    `distage-testkit-core` % "test->compile;compile->compile",
    `distage-testkit-scalatest` % "test->compile;compile->compile",
    `distage-testkit-scalatest-sbt-module-filtering-test` % "test->compile;compile->compile",
    `logstage-coreJVM` % "test->compile;compile->compile",
    `logstage-rendering-circeJVM` % "test->compile;compile->compile",
    `logstage-adapter-slf4j` % "test->compile;compile->compile",
    `logstage-sink-slf4j` % "test->compile;compile->compile"
  )
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test,
      "org.typelevel" %% "cats-core" % V.cats,
      "org.typelevel" %% "cats-effect" % V.cats_effect,
      "dev.zio" %% "zio" % V.zio excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %% "zio-interop-cats" % V.zio_interop_cats excludeAll("dev.zio" %% "izumi-reflect"),
      "dev.zio" %% "izumi-reflect" % V.izumi_reflect,
      "org.tpolecat" %% "doobie-core" % V.doobie,
      "org.tpolecat" %% "doobie-postgres" % V.doobie,
      "io.circe" %% "circe-generic" % V.circe,
      "dev.zio" %% "zio-managed" % V.zio excludeAll("dev.zio" %% "izumi-reflect")
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "2.13.14",
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    SettingKey[Boolean]("ide-skip-project") := true,
    scalacOptions -= "-Wconf:any:error",
    scalacOptions -= "-Xsource:3",
    Compile / sbt.Keys.doc / scalacOptions += "-Xsource:3",
    coverageEnabled := false,
    publish / skip := true,
    DocKeys.prefix := {if (isSnapshot.value) {
                (s => s"latest/snapshot/$s")
              } else {
                identity
              }},
    previewFixedPort := Some(9999),
    gitRemoteRepo := "git@github.com:7mind/izumi-microsite.git",
    mdocIn := baseDirectory.value / "src/main/tut",
    (Compile / paradox) / sourceDirectory := mdocOut.value,
    mdocExtraArguments ++= Seq(
      " --no-link-hygiene"
    ),
    SitePlugin.autoImport.makeSite / mappings := {
                (SitePlugin.autoImport.makeSite / mappings)
                  .dependsOn(mdoc.toTask(" "))
                  .value
              },
    (Compile / paradox) / version := version.value,
    ParadoxMaterialThemePlugin.paradoxMaterialThemeSettings,
    addMappingsToSiteDir(ScalaUnidoc / packageDoc / mappings, ScalaUnidoc / siteSubdirName),
    ScalaUnidoc / unidoc / unidocProjectFilter := inAggregates(`fundamentals-jvm`, transitive = true) || inAggregates(`distage-jvm`, transitive = true) || inAggregates(`logstage-jvm`, transitive = true),
    Compile / ParadoxMaterialThemePlugin.autoImport.paradoxMaterialTheme ~= {
                _.withCopyright("7mind.io")
                  .withRepository(uri("https://github.com/7mind/izumi"))
                //        .withColor("222", "434343")
              },
    ScalaUnidoc / siteSubdirName := DocKeys.prefix.value("api"),
    Paradox / siteSubdirName := DocKeys.prefix.value(""),
    paradoxProperties ++= Map(
                "scaladoc.izumi.base_url" -> s"/${DocKeys.prefix.value("api")}",
                "scaladoc.base_url" -> s"/${DocKeys.prefix.value("api")}",
                "izumi.version" -> version.value,
                "kindprojector.version" -> V.kind_projector,
              ),
    ghpagesCleanSite / excludeFilter :=
                new FileFilter {
                  def accept(f: File): Boolean = {
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("latest")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("distage")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("logstage")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("idealingua")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("bio")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("sbt")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("manifesto")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("pper")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("api")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("assets")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("lib")) ||
                      f.toPath.startsWith(ghpagesRepository.value.toPath.resolve("search")) ||
                      f.toPath.startsWith((ghpagesRepository.value / "media").toPath) ||
                      (ghpagesRepository.value / "paradox.json").getCanonicalPath == f.getCanonicalPath ||
                      (ghpagesRepository.value / "CNAME").getCanonicalPath == f.getCanonicalPath ||
                      (ghpagesRepository.value / ".nojekyll").getCanonicalPath == f.getCanonicalPath ||
                      (ghpagesRepository.value / "README.md").getCanonicalPath == f.getCanonicalPath || (
                          f.toPath.getParent.toAbsolutePath == (ghpagesRepository.value / "index.html").toPath.getParent.toAbsolutePath &&
                            f.getCanonicalPath.endsWith(".html")
                      )
                  }
                },
    libraryDependencies += "io.7mind.izumi.sbt" % "sbtgen_2.13" % "0.0.102"
  )
  .enablePlugins(ScalaUnidocPlugin, ParadoxSitePlugin, SitePlugin, GhpagesPlugin, ParadoxMaterialThemePlugin, PreprocessPlugin, MdocPlugin, SitePreviewPlugin)
  .disablePlugins(ScoverageSbtPlugin, AssemblyPlugin)

lazy val `sbt-izumi-deps` = project.in(file("sbt-plugins/sbt-izumi-deps"))
  .settings(
    libraryDependencies ++= Seq(
      "org.scala-lang.modules" %% "scala-collection-compat" % V.collection_compat,
      "org.scalatest" %% "scalatest" % V.scalatest % Test
    ),
    libraryDependencies ++= { if (scalaVersion.value.startsWith("2.")) Seq(
      compilerPlugin("org.typelevel" % "kind-projector" % V.kind_projector cross CrossVersion.full)
    ) else Seq.empty }
  )
  .settings(
    crossScalaVersions := Seq(
      "2.12.19"
    ),
    scalaVersion := crossScalaVersions.value.head,
    coverageEnabled := false,
    organization := "io.7mind.izumi",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:product-name=${name.value}",
      s"-Xmacro-settings:product-version=${version.value}",
      s"-Xmacro-settings:product-group=${organization.value}",
      s"-Xmacro-settings:scala-version=${scalaVersion.value}",
      s"-Xmacro-settings:scala-versions=${crossScalaVersions.value.mkString(":")}"
    ),
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val ltEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ <= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => ltEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n+") }
        case _ => Seq.empty
      }
    },
    Compile / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Compile / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / unmanagedSourceDirectories ++= {
      val version = scalaVersion.value
      val crossVersions = crossScalaVersions.value
      import Ordering.Implicits._
      val gtEqVersions = crossVersions.map(CrossVersion.partialVersion).filter(_ >= CrossVersion.partialVersion(version)).flatten
      (Test / unmanagedSourceDirectories).value.flatMap {
        case dir if dir.getPath.endsWith("scala") => gtEqVersions.map { case (m, n) => file(dir.getPath + s"-$m.$n-") }
        case _ => Seq.empty
      }
    },
    Test / testOptions += Tests.Argument("-oDF"),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.12.19") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-Xsource:3",
        "-P:kind-projector:underscore-placeholders",
        "-Ypartial-unification",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Xlint:adapted-args",
        "-Xlint:by-name-right-associative",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-override",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:unsound-match",
        "-opt-warnings:_",
        "-Ywarn-extra-implicit",
        "-Ywarn-unused:_",
        "-Ywarn-adapted-args",
        "-Ywarn-dead-code",
        "-Ywarn-inaccessible",
        "-Ywarn-infer-any",
        "-Ywarn-nullary-override",
        "-Ywarn-nullary-unit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused-import",
        "-Ywarn-value-discard",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified"
      )
      case (_, "2.13.14") => Seq(
        "-Wconf:any:error",
        "-release:8",
        "-explaintypes",
        "-P:kind-projector:underscore-placeholders",
        if (insideCI.value) "-Wconf:any:error" else "-Wconf:any:warning",
        "-Wconf:cat=optimizer:warning",
        "-Wconf:cat=other-match-analysis:error",
        "-Vimplicits",
        "-Vtype-diffs",
        "-Ybackend-parallelism",
        math.min(16, math.max(1, sys.runtime.availableProcessors() - 1)).toString,
        "-Wdead-code",
        "-Wextra-implicit",
        "-Wnumeric-widen",
        "-Woctal-literal",
        "-Wvalue-discard",
        "-Wunused:_",
        "-Wmacros:default",
        "-Ycache-plugin-class-loader:always",
        "-Ycache-macro-class-loader:last-modified",
        "-Wunused:-synthetics"
      )
      case (_, "3.3.4-RC2") => Seq(
        "-language:3.4",
        "-release:8",
        "-Ykind-projector:underscores",
        "-Yretain-trees",
        "-no-indent",
        "-explain",
        "-explain-types",
        "-Xmax-inlines:64",
        "-Wconf:msg=eta-expanded even though:silent"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "3.3.4-RC2") => Seq(
        "-Wconf:any:verbose",
        "-Wconf:msg=.this. qualifier will be deprecated:silent",
        "-Wconf:msg=scala.compiletime.uninitialized:silent",
        "-Wconf:msg=`using` clause:silent",
        "-Wconf:msg=eta-expanded even though:silent",
        "-Wconf:msg=The syntax ..function:silent",
        "-Wconf:msg=method contains is not declared infix:silent",
        "-Wconf:msg=method in is not declared infix:silent"
      )
      case (_, _) => Seq(
        "-Wconf:msg=parameter.*x\\$4.in.anonymous.function.is.never.used:silent",
        "-Wconf:msg=constructor.modifiers.are.assumed.by.synthetic.*method:silent",
        "-Wconf:msg=package.object.inheritance:silent",
        "-Wconf:cat=lint-eta-sam:silent"
      )
    } },
    scalacOptions -= "-Wconf:any:warning",
    scalacOptions += "-Wconf:cat=deprecation:warning",
    scalacOptions += "-Wconf:msg=legacy-binding:silent",
    scalacOptions += "-Wconf:msg=nowarn:silent",
    Compile / sbt.Keys.doc / scalacOptions -= "-Wconf:any:error",
    scalacOptions ++= Seq(
      s"-Xmacro-settings:scalatest-version=${V.scalatest}",
      s"-Xmacro-settings:is-ci=${insideCI.value}"
    ),
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (false, "2.12.19") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (false, "2.13.14") => Seq(
        "-opt:l:inline",
        "-opt-inline-from:izumi.**"
      )
      case (_, _) => Seq.empty
    } },
    scalacOptions ++= { (isSnapshot.value, scalaVersion.value) match {
      case (_, "2.13.14") => Seq(
        "-Xsource:3",
        "-Xmigration",
        "-Wconf:cat=scala3-migration:silent",
        "-Wconf:cat=other-migration:silent"
      )
      case (_, _) => Seq.empty
    } },
    Test / packageDoc / publishArtifact := false,
    sbtPlugin := true,
    withBuildInfo("izumi.sbt.deps", "Izumi"),
    SettingKey[Boolean]("ide-skip-project") := true
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(ScoverageSbtPlugin, AssemblyPlugin)

lazy val `fundamentals` = (project in file(".agg/fundamentals-fundamentals"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `fundamentals-basicsJVM`,
    `fundamentals-basicsJS`,
    `fundamentals-functionalJVM`,
    `fundamentals-functionalJS`,
    `fundamentals-collectionsJVM`,
    `fundamentals-collectionsJS`,
    `fundamentals-literalsJVM`,
    `fundamentals-literalsJS`,
    `fundamentals-orphansJVM`,
    `fundamentals-orphansJS`,
    `fundamentals-languageJVM`,
    `fundamentals-languageJS`,
    `fundamentals-platformJVM`,
    `fundamentals-platformJS`,
    `fundamentals-functoidJVM`,
    `fundamentals-functoidJS`,
    `fundamentals-json-circeJVM`,
    `fundamentals-json-circeJS`,
    `fundamentals-bioJVM`,
    `fundamentals-bioJS`
  )

lazy val `fundamentals-jvm` = (project in file(".agg/fundamentals-fundamentals-jvm"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `fundamentals-basicsJVM`,
    `fundamentals-functionalJVM`,
    `fundamentals-collectionsJVM`,
    `fundamentals-literalsJVM`,
    `fundamentals-orphansJVM`,
    `fundamentals-languageJVM`,
    `fundamentals-platformJVM`,
    `fundamentals-functoidJVM`,
    `fundamentals-json-circeJVM`,
    `fundamentals-bioJVM`
  )

lazy val `fundamentals-js` = (project in file(".agg/fundamentals-fundamentals-js"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `fundamentals-basicsJS`,
    `fundamentals-functionalJS`,
    `fundamentals-collectionsJS`,
    `fundamentals-literalsJS`,
    `fundamentals-orphansJS`,
    `fundamentals-languageJS`,
    `fundamentals-platformJS`,
    `fundamentals-functoidJS`,
    `fundamentals-json-circeJS`,
    `fundamentals-bioJS`
  )

lazy val `distage` = (project in file(".agg/distage-distage"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `distage-core-apiJVM`,
    `distage-core-apiJS`,
    `distage-core-proxy-bytebuddy`,
    `distage-framework-apiJVM`,
    `distage-framework-apiJS`,
    `distage-coreJVM`,
    `distage-coreJS`,
    `distage-extension-configJVM`,
    `distage-extension-configJS`,
    `distage-extension-logstageJVM`,
    `distage-extension-logstageJS`,
    `distage-extension-pluginsJVM`,
    `distage-extension-pluginsJS`,
    `distage-frameworkJVM`,
    `distage-frameworkJS`,
    `distage-framework-docker`,
    `distage-testkit-core`,
    `distage-testkit-scalatest`,
    `distage-testkit-scalatest-sbt-module-filtering-test`
  )

lazy val `distage-jvm` = (project in file(".agg/distage-distage-jvm"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `distage-core-apiJVM`,
    `distage-core-proxy-bytebuddy`,
    `distage-framework-apiJVM`,
    `distage-coreJVM`,
    `distage-extension-configJVM`,
    `distage-extension-logstageJVM`,
    `distage-extension-pluginsJVM`,
    `distage-frameworkJVM`,
    `distage-framework-docker`,
    `distage-testkit-core`,
    `distage-testkit-scalatest`,
    `distage-testkit-scalatest-sbt-module-filtering-test`
  )

lazy val `distage-js` = (project in file(".agg/distage-distage-js"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `distage-core-apiJS`,
    `distage-framework-apiJS`,
    `distage-coreJS`,
    `distage-extension-configJS`,
    `distage-extension-logstageJS`,
    `distage-extension-pluginsJS`,
    `distage-frameworkJS`
  )

lazy val `logstage` = (project in file(".agg/logstage-logstage"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `logstage-coreJVM`,
    `logstage-coreJS`,
    `logstage-rendering-circeJVM`,
    `logstage-rendering-circeJS`,
    `logstage-adapter-slf4j`,
    `logstage-sink-slf4j`
  )

lazy val `logstage-jvm` = (project in file(".agg/logstage-logstage-jvm"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `logstage-coreJVM`,
    `logstage-rendering-circeJVM`,
    `logstage-adapter-slf4j`,
    `logstage-sink-slf4j`
  )

lazy val `logstage-js` = (project in file(".agg/logstage-logstage-js"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `logstage-coreJS`,
    `logstage-rendering-circeJS`
  )

lazy val `docs` = (project in file(".agg/doc-docs"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `microsite`
  )

lazy val `docs-jvm` = (project in file(".agg/doc-docs-jvm"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `microsite`
  )

lazy val `sbt-plugins` = (project in file(".agg/sbt-plugins-sbt-plugins"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `sbt-izumi-deps`
  )

lazy val `sbt-plugins-jvm` = (project in file(".agg/sbt-plugins-sbt-plugins-jvm"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `sbt-izumi-deps`
  )

lazy val `izumi-jvm` = (project in file(".agg/.agg-jvm"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `fundamentals-jvm`,
    `distage-jvm`,
    `logstage-jvm`,
    `sbt-plugins-jvm`
  )

lazy val `izumi-js` = (project in file(".agg/.agg-js"))
  .settings(
    publish / skip := true,
    SettingKey[Boolean]("ide-skip-project") := true,
    crossScalaVersions := Nil
  )
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `fundamentals-js`,
    `distage-js`,
    `logstage-js`
  )

lazy val `izumi` = (project in file("."))
  .settings(
    publish / skip := true,
    Global / onChangedBuildSource := ReloadOnSourceChanges,
    ThisBuild / publishMavenStyle := true,
    ThisBuild / scalacOptions ++= Seq(
      "-encoding",
      "UTF-8",
      "-feature",
      "-unchecked",
      "-deprecation",
      "-language:higherKinds"
    ),
    ThisBuild / javacOptions ++= Seq(
      "-encoding",
      "UTF-8",
      "-source",
      "1.8",
      "-target",
      "1.8",
      "-deprecation",
      "-parameters",
      "-Xlint:all",
      "-XDignore.symbol.file"
    ),
    ThisBuild / scalacOptions ++= Seq(
      s"-Xmacro-settings:sbt-version=${sbtVersion.value}",
      s"-Xmacro-settings:git-repo-clean=${com.github.sbt.git.SbtGit.GitKeys.gitUncommittedChanges.value}",
      s"-Xmacro-settings:git-branch=${com.github.sbt.git.SbtGit.GitKeys.gitCurrentBranch.value}",
      s"-Xmacro-settings:git-described-version=${com.github.sbt.git.SbtGit.GitKeys.gitDescribedVersion.value.getOrElse("")}",
      s"-Xmacro-settings:git-head-commit=${com.github.sbt.git.SbtGit.GitKeys.gitHeadCommit.value.getOrElse("")}"
    ),
    crossScalaVersions := Nil,
    ThisBuild / organization := "io.7mind.izumi",
    sonatypeProfileName := "io.7mind",
    sonatypeSessionName := s"[sbt-sonatype] ${name.value} ${version.value} ${java.util.UUID.randomUUID}",
    ThisBuild / publishTo := 
    (if (!isSnapshot.value) {
        sonatypePublishToBundle.value
      } else {
        Some(Opts.resolver.sonatypeSnapshots)
    })
    ,
    ThisBuild / credentials ++= 
    {
    val credTarget = Path.userHome / ".sbt" / "secrets" / "credentials.sonatype-nexus.properties"
    if (credTarget.exists) {
      Seq(Credentials(credTarget))
    } else {
      Seq.empty
    }
    },
    ThisBuild / credentials ++= 
    {
    val credTarget = file(".") / ".secrets" / "credentials.sonatype-nexus.properties"
    if (credTarget.exists) {
      Seq(Credentials(credTarget))
    } else {
      Seq.empty
    }
    },
    ThisBuild / homepage := Some(url("https://izumi.7mind.io")),
    ThisBuild / licenses := Seq("BSD-style" -> url("http://www.opensource.org/licenses/bsd-license.php")),
    ThisBuild / developers := List(
              Developer(id = "7mind", name = "Septimal Mind", url = url("https://github.com/7mind"), email = "team@7mind.io"),
            ),
    ThisBuild / scmInfo := Some(ScmInfo(url("https://github.com/7mind/izumi"), "scm:git:https://github.com/7mind/izumi.git"))
  )
  .enablePlugins(SitePreviewPlugin)
  .disablePlugins(AssemblyPlugin)
  .aggregate(
    `fundamentals`,
    `distage`,
    `logstage`,
    `sbt-plugins`
  )
